package pubresolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.49

import (
	"context"
	"slices"

	"github.com/azarc-io/verathread-gateway/internal/gql/graph/common/model"
	pubgraph "github.com/azarc-io/verathread-gateway/internal/gql/graph/public"
	apptypes "github.com/azarc-io/verathread-gateway/internal/types"
	nats "github.com/nats-io/nats.go"
	"github.com/rs/zerolog/log"
)

// ShellConfiguration is the resolver for the shellConfiguration field.
func (r *subscriptionResolver) ShellConfiguration(ctx context.Context, tenantID string, events []model.ShellConfigEventType) (<-chan *model.ShellConfigurationSubscription, error) {
	var (
		ch  = make(chan *model.ShellConfigurationSubscription, 1)
		nc  = r.Opts.NatsUseCase.Client()
		sub *nats.Subscription
		err error
	)

	// load initial apps config
	if slices.Index(events, model.ShellConfigEventTypeInitial) > -1 {
		if cfg, err := r.InternalService.GetAppConfiguration(ctx, tenantID); err != nil {
			return nil, err
		} else {
			ch <- &model.ShellConfigurationSubscription{
				Configuration: cfg,
				EventType:     model.ShellConfigEventTypeInitial,
			}
		}

		// subscribe to patch updates
		sub, err = nc.Subscribe(apptypes.ShellConfigurationUpdatedSubject, func(msg *nats.Msg) {
			if cfg, err := r.InternalService.GetAppConfiguration(ctx, tenantID); err != nil {
				log.Warn().Err(err).Msgf("failed to fetch app configuration for shell sync")
			} else {
				ch <- &model.ShellConfigurationSubscription{
					Configuration: cfg,
					EventType:     model.ShellConfigEventTypeUpdated,
				}
			}
		})

		if err != nil {
			close(ch)
		}
	}

	go func() {
		<-ctx.Done()
		log.Info().Msgf("socket closed")
		if sub != nil {
			_ = sub.Unsubscribe()
		}
	}()

	// We return the channel and no error.
	return ch, nil
}

// Subscription returns pubgraph.SubscriptionResolver implementation.
func (r *Resolver) Subscription() pubgraph.SubscriptionResolver { return &subscriptionResolver{r} }

type subscriptionResolver struct{ *Resolver }
