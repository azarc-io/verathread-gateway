schema {
  query: Query
  mutation: Mutation
  subscription: Subscription
}

directive @goField(forceResolver: String, name: String) on FIELD_DEFINITION | INPUT_FIELD_DEFINITION

directive @nestedQueries on INPUT_FIELD_DEFINITION

directive @query on INPUT_FIELD_DEFINITION

directive @queryCondition on INPUT_FIELD_DEFINITION

directive @queryField on INPUT_FIELD_DEFINITION

directive @queryFieldExists on INPUT_FIELD_DEFINITION

directive @queryFields on INPUT_FIELD_DEFINITION

directive @queryOp on INPUT_FIELD_DEFINITION

directive @queryRules on INPUT_FIELD_DEFINITION

directive @queryType(type: QueryType!) on INPUT_FIELD_DEFINITION

directive @queryValue on INPUT_FIELD_DEFINITION

directive @ref(dependencies: [String], field: String) on FIELD_DEFINITION | INPUT_FIELD_DEFINITION

directive @refRoot(id: RefRoot!) on FIELD_DEFINITION

directive @validation(constraint: String!) on ARGUMENT_DEFINITION | INPUT_FIELD_DEFINITION

directive @warden(action: String!, filterField: String, resource: String!, resourceKey: String) on FIELD_DEFINITION

scalar Any

scalar Duration

input KeepAliveAppInput {
  name: String!
  pkg: String!
  version: String!
}

type KeepAliveAppOutput {
  ok: Boolean!
  registrationRequired: Boolean!
}

type Mutation {
  keepAlive(input: KeepAliveAppInput): KeepAliveAppOutput!
  registerApp(input: RegisterAppInput!): RegisterAppOutput!
}

input Page {
  limit: Int @ref(field: "limit")
  page: Int @ref(field: "page")
}

type PageInfo {
  next: Int!
  page: Int!
  perPage: Int!
  prev: Int!
  total: Int!
  totalPage: Int!
}

type Query {
  registeredApps(page: Page!, sort: RegisteredAppsSort, where: RegisteredAppsWhereRules): RegisteredAppsPage
  shellConfiguration(tenantId: String!): ShellConfiguration!
}

enum QueryCondition {
  And
  Or
}

input QueryOperatorAndDate {
  op: QueryOperators! @queryOp
  value: Time @queryValue
}

input QueryOperatorAndValue {
  op: QueryOperators! @queryOp
  value: Any @queryValue
}

input QueryOperatorFieldAndValue {
  exists: Boolean @queryFieldExists
  field: String! @queryField
  op: QueryOperators! @queryOp
  value: Any @queryValue
}

enum QueryOperators {
  Contains
  Equal
  GreaterThan
  GreaterThanOrEqual
  In
  LessThan
  LessThanOrEqual
  NotEqual
  NotIn
  Regex
}

enum QueryType {
  Date
  Deleted
}

input QueryValue {
  value: Any @queryValue
}

enum RefRoot {
  AppRef
}

enum RegisterAppCategory {
  App
  Dashboard
  Setting
}

input RegisterAppInput {
  apiUrl: String!
  id: String!
  name: String!
  navigation: [RegisterAppNavigationInput]
  package: String!
  proxy: Boolean!
  remoteEntryFile: String!
  slot1: RegisterAppSlot
  slot2: RegisterAppSlot
  slot3: RegisterAppSlot
  version: String!
  webUrl: String!
}

input RegisterAppModule {
  exposedModule: String!
  moduleName: String!
  outlet: String!
  path: String!
}

input RegisterAppNavigationInput {
  authRequired: Boolean!
  category: RegisterAppCategory!
  children: [RegisterChildAppNavigationInput]
  hidden: Boolean!
  icon: String!
  module: RegisterAppModule!
  proxy: Boolean!
  subTitle: String!
  title: String!
}

type RegisterAppOutput {
  id: String!
}

input RegisterAppSlot {
  authRequired: Boolean!
  description: String!
  module: RegisterAppSlotModule!
}

input RegisterAppSlotModule {
  exposedModule: String!
  moduleName: String!
  path: String!
}

input RegisterChildAppNavigationInput {
  authRequired: Boolean!
  children: [RegisterChildAppNavigationInput]
  icon: String!
  module: RegisterAppModule!
  path: String!
  subTitle: String!
  title: String!
}

type RegisteredApp {
  createdAt: Time @ref(field: "created_at")
  name: String @ref(field: "name")
  pkg: String! @ref(field: "package")
  updatedAt: Time @ref(field: "updated_at")
}

input RegisteredAppQueryFields {
  createdAt: QueryOperatorAndDate @ref(field: "created_at") @queryType(type: Date)
  name: QueryOperatorAndValue @ref(field: "name")
  updatedAt: QueryOperatorAndDate @ref(field: "updated_at") @queryType(type: Date)
}

type RegisteredAppsPage {
  data: [RegisteredApp] @refRoot(id: AppRef)
  page: PageInfo!
}

input RegisteredAppsSort {
  createdAt: SortType @ref(field: "created_at") @queryType(type: Date)
  name: SortType @ref(field: "name")
  updatedAt: SortType @ref(field: "updated_at") @queryType(type: Date)
}

input RegisteredAppsWhereRules {
  condition: QueryCondition! @queryCondition
  fields: [RegisteredAppQueryFields] @queryOp
  rules: [RegisteredAppsWhereRules] @queryRules
}

enum ShellConfigEventType {
  Added
  Initial
  Rebuild
  Removed
  Updated
}

type ShellConfiguration {
  categories: [ShellNavigationCategory]
  defaultRoute: String
  slots: [ShellNavigationSlot]
}

type ShellConfigurationSubscription {
  configuration: ShellConfiguration!
  eventType: ShellConfigEventType!
}

type ShellNavigation {
  authRequired: Boolean! @ref(field: "authRequired")
  children: [ShellNavigationChild] @ref(field: "children")
  healthy: Boolean! @ref(field: "available")
  hidden: Boolean! @ref(field: "hidden")
  icon: String! @ref(field: "icon")
  id: String! @ref(field: "_id")
  module: ShellNavigationModule! @ref(field: "module")
  subTitle: String! @ref(field: "subTitle")
  title: String! @ref(field: "title")
}

type ShellNavigationCategory {
  category: RegisterAppCategory!
  entries: [ShellNavigation]
  priority: Int!
  title: String!
}

type ShellNavigationChild {
  authRequired: Boolean! @ref(field: "authRequired")
  children: [ShellNavigationChild] @ref(field: "children")
  healthy: Boolean! @ref(field: "available")
  icon: String! @ref(field: "icon")
  module: ShellNavigationModule! @ref(field: "module")
  subTitle: String! @ref(field: "subTitle")
  title: String! @ref(field: "title")
}

type ShellNavigationModule {
  exposedModule: String! @ref(field: "exposedModule")
  moduleName: String! @ref(field: "moduleName")
  outlet: String! @ref(field: "outlet")
  path: String! @ref(field: "path")
  remoteEntry: String! @ref(field: "remoteEntry")
}

type ShellNavigationSlot {
  authRequired: Boolean @ref(field: "authRequired")
  description: String! @ref(field: "description")
  module: ShellNavigationSlotModule! @ref(field: "module")
  priority: Int
  slot: String! @ref(field: "slot")
}

type ShellNavigationSlotModule {
  exposedModule: String! @ref(field: "exposedModule")
  moduleName: String! @ref(field: "moduleName")
  path: String! @ref(field: "path")
  remoteEntry: String! @ref(field: "remoteEntry")
}

input Sort {
  key: String!
  type: SortType!
}

enum SortType {
  ASC
  DES
}

type Subscription {
  shellConfiguration(events: [ShellConfigEventType!]!, tenantId: String!): ShellConfigurationSubscription!
}

type TagValue {
  Value: Any! @ref(field: "value")
}

type TagValues {
  Key: String! @ref(field: "key")
  Values: [TagValue] @ref(field: "values")
}

scalar Time